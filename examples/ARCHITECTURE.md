# Examples Architecture

All examples are **standalone projects** in their own directories.

## TL;DR

**For Linux/POSIX:**
```bash
cd examples/dpp-linux
cargo run --release --target x86_64-unknown-linux-gnu
```

**For ESP32-C6 embedded:**
```bash
cd examples/dpp-esp32c6
cargo build --release
espflash flash --monitor
```

---

## Standalone Project Structure

Each example is a complete project with all necessary infrastructure:

### Linux Example (`examples/dpp-linux/`)

```
examples/dpp-linux/
├── Cargo.toml          # Standalone package with ports/posix
├── src/
│   └── main.rs         # Application with QS tracing
└── target/             # Build artifacts
```

**Dependencies**:
- `qp-*` framework crates
- `ports/posix` - Middleware for Linux/Unix

**Features**:
- QS tracing to stdout via `println!`
- Native threading and synchronization
- Standard library support

### Embedded Example (`examples/dpp-esp32c6/`)

```
examples/dpp-esp32c6/
├── Cargo.toml          # Standalone package with ports/esp32c6
├── .cargo/config.toml  # RISC-V target configuration
├── build.rs            # Platform-specific build script
├── src/
│   └── main.rs         # Application code
└── target/             # Build artifacts
```

**Dependencies**:
- `qp-*` framework crates (no_std)
- `ports/esp32c6` - Middleware for ESP32-C6
- `esp-hal`, `esp-backtrace`, `esp-println` - HAL and utilities

**Infrastructure**:
- `memory.x` and `link.x` generated by esp-hal's build.rs
- Interrupt vector setup
- no_std bare-metal environment
- UART-based QS tracing (planned)

---

## Why Standalone Projects for Everything?

**Consistency**: Same pattern for native and embedded targets

**Required for Embedded**:
- Board-specific linker scripts (memory.x, link.x)
- Interrupt vector tables
- Memory layout definitions
- Build scripts for platform code generation

**Benefits for Native**:
- Isolated dependencies per platform
- No feature flag complexity
- Easier testing and maintenance
- Cleaner build process

---

## Dependency Flow

```
Application (examples/dpp-linux/)
    ↓
Port Layer (ports/posix/)
    ↓
QP Framework (qp/*)
    ↓
Hardware (Linux kernel, std library)
```

```
Application (examples/dpp-esp32c6/)
    ↓
Port Layer (ports/esp32c6/)
    ↓
QP Framework (qp/*, no_std)
    ↓
Board Support (boards/esp32c6/)
    ↓
Hardware (ESP32-C6 RISC-V)
```

---

## Adding New Examples

### For Any Platform

Create a new standalone project:

```bash
cd examples
cargo new --name myexample myexample-platform
cd myexample-platform
```

Add dependencies to `Cargo.toml`:

```toml
[dependencies]
qp-core = { path = "../../qp/core" }
qp-qep = { path = "../../qp/qep" }
qp-qf = { path = "../../qp/qf" }
qp-qv = { path = "../../qp/qv" }

# Choose appropriate port
posix = { path = "../../ports/posix" }         # For Linux/Unix
# OR
esp32c6 = { path = "../../ports/esp32c6" }     # For ESP32-C6
```

Add to workspace exclude list in root `Cargo.toml`:

```toml
exclude = [
    "examples/blinky",
    "examples/dpp-linux",
    "examples/dpp-esp32c6",
    "examples/myexample-platform",  # New!
]
```---

## Frequently Asked Questions

**Q: Why not make the workspace example work for embedded?**

A: It's not possible without duplicating all the build infrastructure (memory.x, link.x, build.rs) that HAL crates provide. The standalone project approach is the standard pattern in the Rust embedded ecosystem.

**Q: Can I delete the workspace examples directory?**

A: Keep it! It will be useful for native examples and serves as a clean reference implementation.

**Q: Will this improve in the future?**

A: Possibly, if Rust embedded tooling evolves to support better workspace integration. For now, standalone projects are the standard approach (see embassy, esp-hal examples, etc.).

---

## References

This architecture follows established patterns in the Rust embedded ecosystem:
- [esp-rs/esp-hal](https://github.com/esp-rs/esp-hal) - Examples are standalone
- [embassy-rs/embassy](https://github.com/embassy-rs/embassy) - Examples are standalone
- [rust-embedded/awesome-embedded-rust](https://github.com/rust-embedded/awesome-embedded-rust)
